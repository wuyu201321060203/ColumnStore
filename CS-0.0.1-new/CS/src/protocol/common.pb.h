// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class SINGLE_NODE_INFO;
class COLUMN_INFO;
class TB_INFO;
class DATABASE_INFO;
class TASK_INFO;
class GROUP_DB_INFO;
class ROWKEY_ENTRY;
class DICT_VALUE;

enum COLUMN_INFO_ColumnType {
  COLUMN_INFO_ColumnType_VARCHAR = 0,
  COLUMN_INFO_ColumnType_INTTYPE = 1,
  COLUMN_INFO_ColumnType_DOUBLETYPE = 2,
  COLUMN_INFO_ColumnType_TEXT = 3,
  COLUMN_INFO_ColumnType_BLOB = 4,
  COLUMN_INFO_ColumnType_TIMESTAMP = 5
};
bool COLUMN_INFO_ColumnType_IsValid(int value);
const COLUMN_INFO_ColumnType COLUMN_INFO_ColumnType_ColumnType_MIN = COLUMN_INFO_ColumnType_VARCHAR;
const COLUMN_INFO_ColumnType COLUMN_INFO_ColumnType_ColumnType_MAX = COLUMN_INFO_ColumnType_TIMESTAMP;
const int COLUMN_INFO_ColumnType_ColumnType_ARRAYSIZE = COLUMN_INFO_ColumnType_ColumnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* COLUMN_INFO_ColumnType_descriptor();
inline const ::std::string& COLUMN_INFO_ColumnType_Name(COLUMN_INFO_ColumnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    COLUMN_INFO_ColumnType_descriptor(), value);
}
inline bool COLUMN_INFO_ColumnType_Parse(
    const ::std::string& name, COLUMN_INFO_ColumnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<COLUMN_INFO_ColumnType>(
    COLUMN_INFO_ColumnType_descriptor(), name, value);
}
// ===================================================================

class SINGLE_NODE_INFO : public ::google::protobuf::Message {
 public:
  SINGLE_NODE_INFO();
  virtual ~SINGLE_NODE_INFO();
  
  SINGLE_NODE_INFO(const SINGLE_NODE_INFO& from);
  
  inline SINGLE_NODE_INFO& operator=(const SINGLE_NODE_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SINGLE_NODE_INFO& default_instance();
  
  void Swap(SINGLE_NODE_INFO* other);
  
  // implements Message ----------------------------------------------
  
  SINGLE_NODE_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SINGLE_NODE_INFO& from);
  void MergeFrom(const SINGLE_NODE_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 nodeId = 1;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 nodeid() const;
  inline void set_nodeid(::google::protobuf::uint32 value);
  
  // optional string nodeStatus = 2;
  inline bool has_nodestatus() const;
  inline void clear_nodestatus();
  static const int kNodeStatusFieldNumber = 2;
  inline const ::std::string& nodestatus() const;
  inline void set_nodestatus(const ::std::string& value);
  inline void set_nodestatus(const char* value);
  inline void set_nodestatus(const char* value, size_t size);
  inline ::std::string* mutable_nodestatus();
  inline ::std::string* release_nodestatus();
  
  // optional string nodeIp = 3;
  inline bool has_nodeip() const;
  inline void clear_nodeip();
  static const int kNodeIpFieldNumber = 3;
  inline const ::std::string& nodeip() const;
  inline void set_nodeip(const ::std::string& value);
  inline void set_nodeip(const char* value);
  inline void set_nodeip(const char* value, size_t size);
  inline ::std::string* mutable_nodeip();
  inline ::std::string* release_nodeip();
  
  // optional uint32 nodePort = 4;
  inline bool has_nodeport() const;
  inline void clear_nodeport();
  static const int kNodePortFieldNumber = 4;
  inline ::google::protobuf::uint32 nodeport() const;
  inline void set_nodeport(::google::protobuf::uint32 value);
  
  // optional uint32 core = 5;
  inline bool has_core() const;
  inline void clear_core();
  static const int kCoreFieldNumber = 5;
  inline ::google::protobuf::uint32 core() const;
  inline void set_core(::google::protobuf::uint32 value);
  
  // optional uint32 memSize = 6;
  inline bool has_memsize() const;
  inline void clear_memsize();
  static const int kMemSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 memsize() const;
  inline void set_memsize(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:SINGLE_NODE_INFO)
 private:
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_nodestatus();
  inline void clear_has_nodestatus();
  inline void set_has_nodeip();
  inline void clear_has_nodeip();
  inline void set_has_nodeport();
  inline void clear_has_nodeport();
  inline void set_has_core();
  inline void clear_has_core();
  inline void set_has_memsize();
  inline void clear_has_memsize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nodestatus_;
  ::google::protobuf::uint32 nodeid_;
  ::google::protobuf::uint32 nodeport_;
  ::std::string* nodeip_;
  ::google::protobuf::uint32 core_;
  ::google::protobuf::uint32 memsize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();
  
  void InitAsDefaultInstance();
  static SINGLE_NODE_INFO* default_instance_;
};
// -------------------------------------------------------------------

class COLUMN_INFO : public ::google::protobuf::Message {
 public:
  COLUMN_INFO();
  virtual ~COLUMN_INFO();
  
  COLUMN_INFO(const COLUMN_INFO& from);
  
  inline COLUMN_INFO& operator=(const COLUMN_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const COLUMN_INFO& default_instance();
  
  void Swap(COLUMN_INFO* other);
  
  // implements Message ----------------------------------------------
  
  COLUMN_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const COLUMN_INFO& from);
  void MergeFrom(const COLUMN_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef COLUMN_INFO_ColumnType ColumnType;
  static const ColumnType VARCHAR = COLUMN_INFO_ColumnType_VARCHAR;
  static const ColumnType INTTYPE = COLUMN_INFO_ColumnType_INTTYPE;
  static const ColumnType DOUBLETYPE = COLUMN_INFO_ColumnType_DOUBLETYPE;
  static const ColumnType TEXT = COLUMN_INFO_ColumnType_TEXT;
  static const ColumnType BLOB = COLUMN_INFO_ColumnType_BLOB;
  static const ColumnType TIMESTAMP = COLUMN_INFO_ColumnType_TIMESTAMP;
  static inline bool ColumnType_IsValid(int value) {
    return COLUMN_INFO_ColumnType_IsValid(value);
  }
  static const ColumnType ColumnType_MIN =
    COLUMN_INFO_ColumnType_ColumnType_MIN;
  static const ColumnType ColumnType_MAX =
    COLUMN_INFO_ColumnType_ColumnType_MAX;
  static const int ColumnType_ARRAYSIZE =
    COLUMN_INFO_ColumnType_ColumnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ColumnType_descriptor() {
    return COLUMN_INFO_ColumnType_descriptor();
  }
  static inline const ::std::string& ColumnType_Name(ColumnType value) {
    return COLUMN_INFO_ColumnType_Name(value);
  }
  static inline bool ColumnType_Parse(const ::std::string& name,
      ColumnType* value) {
    return COLUMN_INFO_ColumnType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string columnName = 1;
  inline bool has_columnname() const;
  inline void clear_columnname();
  static const int kColumnNameFieldNumber = 1;
  inline const ::std::string& columnname() const;
  inline void set_columnname(const ::std::string& value);
  inline void set_columnname(const char* value);
  inline void set_columnname(const char* value, size_t size);
  inline ::std::string* mutable_columnname();
  inline ::std::string* release_columnname();
  
  // required .COLUMN_INFO.ColumnType columnType = 2;
  inline bool has_columntype() const;
  inline void clear_columntype();
  static const int kColumnTypeFieldNumber = 2;
  inline ::COLUMN_INFO_ColumnType columntype() const;
  inline void set_columntype(::COLUMN_INFO_ColumnType value);
  
  // @@protoc_insertion_point(class_scope:COLUMN_INFO)
 private:
  inline void set_has_columnname();
  inline void clear_has_columnname();
  inline void set_has_columntype();
  inline void clear_has_columntype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* columnname_;
  int columntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();
  
  void InitAsDefaultInstance();
  static COLUMN_INFO* default_instance_;
};
// -------------------------------------------------------------------

class TB_INFO : public ::google::protobuf::Message {
 public:
  TB_INFO();
  virtual ~TB_INFO();
  
  TB_INFO(const TB_INFO& from);
  
  inline TB_INFO& operator=(const TB_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TB_INFO& default_instance();
  
  void Swap(TB_INFO* other);
  
  // implements Message ----------------------------------------------
  
  TB_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TB_INFO& from);
  void MergeFrom(const TB_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tbName = 1;
  inline bool has_tbname() const;
  inline void clear_tbname();
  static const int kTbNameFieldNumber = 1;
  inline const ::std::string& tbname() const;
  inline void set_tbname(const ::std::string& value);
  inline void set_tbname(const char* value);
  inline void set_tbname(const char* value, size_t size);
  inline ::std::string* mutable_tbname();
  inline ::std::string* release_tbname();
  
  // repeated .COLUMN_INFO columnInfo = 2;
  inline int columninfo_size() const;
  inline void clear_columninfo();
  static const int kColumnInfoFieldNumber = 2;
  inline const ::COLUMN_INFO& columninfo(int index) const;
  inline ::COLUMN_INFO* mutable_columninfo(int index);
  inline ::COLUMN_INFO* add_columninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO >&
      columninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO >*
      mutable_columninfo();
  
  // required uint32 rowNum = 3;
  inline bool has_rownum() const;
  inline void clear_rownum();
  static const int kRowNumFieldNumber = 3;
  inline ::google::protobuf::uint32 rownum() const;
  inline void set_rownum(::google::protobuf::uint32 value);
  
  // required uint32 tbSize = 4;
  inline bool has_tbsize() const;
  inline void clear_tbsize();
  static const int kTbSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 tbsize() const;
  inline void set_tbsize(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:TB_INFO)
 private:
  inline void set_has_tbname();
  inline void clear_has_tbname();
  inline void set_has_rownum();
  inline void clear_has_rownum();
  inline void set_has_tbsize();
  inline void clear_has_tbsize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* tbname_;
  ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO > columninfo_;
  ::google::protobuf::uint32 rownum_;
  ::google::protobuf::uint32 tbsize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();
  
  void InitAsDefaultInstance();
  static TB_INFO* default_instance_;
};
// -------------------------------------------------------------------

class DATABASE_INFO : public ::google::protobuf::Message {
 public:
  DATABASE_INFO();
  virtual ~DATABASE_INFO();
  
  DATABASE_INFO(const DATABASE_INFO& from);
  
  inline DATABASE_INFO& operator=(const DATABASE_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DATABASE_INFO& default_instance();
  
  void Swap(DATABASE_INFO* other);
  
  // implements Message ----------------------------------------------
  
  DATABASE_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DATABASE_INFO& from);
  void MergeFrom(const DATABASE_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dbName = 1;
  inline bool has_dbname() const;
  inline void clear_dbname();
  static const int kDbNameFieldNumber = 1;
  inline const ::std::string& dbname() const;
  inline void set_dbname(const ::std::string& value);
  inline void set_dbname(const char* value);
  inline void set_dbname(const char* value, size_t size);
  inline ::std::string* mutable_dbname();
  inline ::std::string* release_dbname();
  
  // required int32 dbid = 2;
  inline bool has_dbid() const;
  inline void clear_dbid();
  static const int kDbidFieldNumber = 2;
  inline ::google::protobuf::int32 dbid() const;
  inline void set_dbid(::google::protobuf::int32 value);
  
  // repeated .TB_INFO tbInfo = 3;
  inline int tbinfo_size() const;
  inline void clear_tbinfo();
  static const int kTbInfoFieldNumber = 3;
  inline const ::TB_INFO& tbinfo(int index) const;
  inline ::TB_INFO* mutable_tbinfo(int index);
  inline ::TB_INFO* add_tbinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::TB_INFO >&
      tbinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::TB_INFO >*
      mutable_tbinfo();
  
  // @@protoc_insertion_point(class_scope:DATABASE_INFO)
 private:
  inline void set_has_dbname();
  inline void clear_has_dbname();
  inline void set_has_dbid();
  inline void clear_has_dbid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dbname_;
  ::google::protobuf::RepeatedPtrField< ::TB_INFO > tbinfo_;
  ::google::protobuf::int32 dbid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();
  
  void InitAsDefaultInstance();
  static DATABASE_INFO* default_instance_;
};
// -------------------------------------------------------------------

class TASK_INFO : public ::google::protobuf::Message {
 public:
  TASK_INFO();
  virtual ~TASK_INFO();
  
  TASK_INFO(const TASK_INFO& from);
  
  inline TASK_INFO& operator=(const TASK_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TASK_INFO& default_instance();
  
  void Swap(TASK_INFO* other);
  
  // implements Message ----------------------------------------------
  
  TASK_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TASK_INFO& from);
  void MergeFrom(const TASK_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 taskType = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype() const;
  inline void set_tasktype(::google::protobuf::uint32 value);
  
  // required uint32 schedule = 2;
  inline bool has_schedule() const;
  inline void clear_schedule();
  static const int kScheduleFieldNumber = 2;
  inline ::google::protobuf::uint32 schedule() const;
  inline void set_schedule(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:TASK_INFO)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_schedule();
  inline void clear_has_schedule();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 tasktype_;
  ::google::protobuf::uint32 schedule_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();
  
  void InitAsDefaultInstance();
  static TASK_INFO* default_instance_;
};
// -------------------------------------------------------------------

class GROUP_DB_INFO : public ::google::protobuf::Message {
 public:
  GROUP_DB_INFO();
  virtual ~GROUP_DB_INFO();
  
  GROUP_DB_INFO(const GROUP_DB_INFO& from);
  
  inline GROUP_DB_INFO& operator=(const GROUP_DB_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GROUP_DB_INFO& default_instance();
  
  void Swap(GROUP_DB_INFO* other);
  
  // implements Message ----------------------------------------------
  
  GROUP_DB_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GROUP_DB_INFO& from);
  void MergeFrom(const GROUP_DB_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string groupName = 1;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  
  // repeated uint32 dbid = 2;
  inline int dbid_size() const;
  inline void clear_dbid();
  static const int kDbidFieldNumber = 2;
  inline ::google::protobuf::uint32 dbid(int index) const;
  inline void set_dbid(int index, ::google::protobuf::uint32 value);
  inline void add_dbid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dbid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dbid();
  
  // @@protoc_insertion_point(class_scope:GROUP_DB_INFO)
 private:
  inline void set_has_groupname();
  inline void clear_has_groupname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* groupname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dbid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();
  
  void InitAsDefaultInstance();
  static GROUP_DB_INFO* default_instance_;
};
// -------------------------------------------------------------------

class ROWKEY_ENTRY : public ::google::protobuf::Message {
 public:
  ROWKEY_ENTRY();
  virtual ~ROWKEY_ENTRY();
  
  ROWKEY_ENTRY(const ROWKEY_ENTRY& from);
  
  inline ROWKEY_ENTRY& operator=(const ROWKEY_ENTRY& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ROWKEY_ENTRY& default_instance();
  
  void Swap(ROWKEY_ENTRY* other);
  
  // implements Message ----------------------------------------------
  
  ROWKEY_ENTRY* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ROWKEY_ENTRY& from);
  void MergeFrom(const ROWKEY_ENTRY& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 rowKey = 1;
  inline bool has_rowkey() const;
  inline void clear_rowkey();
  static const int kRowKeyFieldNumber = 1;
  inline ::google::protobuf::uint64 rowkey() const;
  inline void set_rowkey(::google::protobuf::uint64 value);
  
  // required uint64 entry = 2;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 2;
  inline ::google::protobuf::uint64 entry() const;
  inline void set_entry(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ROWKEY_ENTRY)
 private:
  inline void set_has_rowkey();
  inline void clear_has_rowkey();
  inline void set_has_entry();
  inline void clear_has_entry();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 rowkey_;
  ::google::protobuf::uint64 entry_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();
  
  void InitAsDefaultInstance();
  static ROWKEY_ENTRY* default_instance_;
};
// -------------------------------------------------------------------

class DICT_VALUE : public ::google::protobuf::Message {
 public:
  DICT_VALUE();
  virtual ~DICT_VALUE();
  
  DICT_VALUE(const DICT_VALUE& from);
  
  inline DICT_VALUE& operator=(const DICT_VALUE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DICT_VALUE& default_instance();
  
  void Swap(DICT_VALUE* other);
  
  // implements Message ----------------------------------------------
  
  DICT_VALUE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DICT_VALUE& from);
  void MergeFrom(const DICT_VALUE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string strValue = 1;
  inline bool has_strvalue() const;
  inline void clear_strvalue();
  static const int kStrValueFieldNumber = 1;
  inline const ::std::string& strvalue() const;
  inline void set_strvalue(const ::std::string& value);
  inline void set_strvalue(const char* value);
  inline void set_strvalue(const char* value, size_t size);
  inline ::std::string* mutable_strvalue();
  inline ::std::string* release_strvalue();
  
  // optional int32 iValue = 2;
  inline bool has_ivalue() const;
  inline void clear_ivalue();
  static const int kIValueFieldNumber = 2;
  inline ::google::protobuf::int32 ivalue() const;
  inline void set_ivalue(::google::protobuf::int32 value);
  
  // optional double dValue = 3;
  inline bool has_dvalue() const;
  inline void clear_dvalue();
  static const int kDValueFieldNumber = 3;
  inline double dvalue() const;
  inline void set_dvalue(double value);
  
  // @@protoc_insertion_point(class_scope:DICT_VALUE)
 private:
  inline void set_has_strvalue();
  inline void clear_has_strvalue();
  inline void set_has_ivalue();
  inline void clear_has_ivalue();
  inline void set_has_dvalue();
  inline void clear_has_dvalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* strvalue_;
  double dvalue_;
  ::google::protobuf::int32 ivalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();
  
  void InitAsDefaultInstance();
  static DICT_VALUE* default_instance_;
};
// ===================================================================


// ===================================================================

// SINGLE_NODE_INFO

// required uint32 nodeId = 1;
inline bool SINGLE_NODE_INFO::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SINGLE_NODE_INFO::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SINGLE_NODE_INFO::clear_nodeid() {
  nodeid_ = 0u;
  clear_has_nodeid();
}
inline ::google::protobuf::uint32 SINGLE_NODE_INFO::nodeid() const {
  return nodeid_;
}
inline void SINGLE_NODE_INFO::set_nodeid(::google::protobuf::uint32 value) {
  set_has_nodeid();
  nodeid_ = value;
}

// optional string nodeStatus = 2;
inline bool SINGLE_NODE_INFO::has_nodestatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_nodestatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SINGLE_NODE_INFO::clear_has_nodestatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SINGLE_NODE_INFO::clear_nodestatus() {
  if (nodestatus_ != &::google::protobuf::internal::kEmptyString) {
    nodestatus_->clear();
  }
  clear_has_nodestatus();
}
inline const ::std::string& SINGLE_NODE_INFO::nodestatus() const {
  return *nodestatus_;
}
inline void SINGLE_NODE_INFO::set_nodestatus(const ::std::string& value) {
  set_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::kEmptyString) {
    nodestatus_ = new ::std::string;
  }
  nodestatus_->assign(value);
}
inline void SINGLE_NODE_INFO::set_nodestatus(const char* value) {
  set_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::kEmptyString) {
    nodestatus_ = new ::std::string;
  }
  nodestatus_->assign(value);
}
inline void SINGLE_NODE_INFO::set_nodestatus(const char* value, size_t size) {
  set_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::kEmptyString) {
    nodestatus_ = new ::std::string;
  }
  nodestatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SINGLE_NODE_INFO::mutable_nodestatus() {
  set_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::kEmptyString) {
    nodestatus_ = new ::std::string;
  }
  return nodestatus_;
}
inline ::std::string* SINGLE_NODE_INFO::release_nodestatus() {
  clear_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodestatus_;
    nodestatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nodeIp = 3;
inline bool SINGLE_NODE_INFO::has_nodeip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_nodeip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SINGLE_NODE_INFO::clear_has_nodeip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SINGLE_NODE_INFO::clear_nodeip() {
  if (nodeip_ != &::google::protobuf::internal::kEmptyString) {
    nodeip_->clear();
  }
  clear_has_nodeip();
}
inline const ::std::string& SINGLE_NODE_INFO::nodeip() const {
  return *nodeip_;
}
inline void SINGLE_NODE_INFO::set_nodeip(const ::std::string& value) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(value);
}
inline void SINGLE_NODE_INFO::set_nodeip(const char* value) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(value);
}
inline void SINGLE_NODE_INFO::set_nodeip(const char* value, size_t size) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SINGLE_NODE_INFO::mutable_nodeip() {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  return nodeip_;
}
inline ::std::string* SINGLE_NODE_INFO::release_nodeip() {
  clear_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeip_;
    nodeip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 nodePort = 4;
inline bool SINGLE_NODE_INFO::has_nodeport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_nodeport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SINGLE_NODE_INFO::clear_has_nodeport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SINGLE_NODE_INFO::clear_nodeport() {
  nodeport_ = 0u;
  clear_has_nodeport();
}
inline ::google::protobuf::uint32 SINGLE_NODE_INFO::nodeport() const {
  return nodeport_;
}
inline void SINGLE_NODE_INFO::set_nodeport(::google::protobuf::uint32 value) {
  set_has_nodeport();
  nodeport_ = value;
}

// optional uint32 core = 5;
inline bool SINGLE_NODE_INFO::has_core() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_core() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SINGLE_NODE_INFO::clear_has_core() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SINGLE_NODE_INFO::clear_core() {
  core_ = 0u;
  clear_has_core();
}
inline ::google::protobuf::uint32 SINGLE_NODE_INFO::core() const {
  return core_;
}
inline void SINGLE_NODE_INFO::set_core(::google::protobuf::uint32 value) {
  set_has_core();
  core_ = value;
}

// optional uint32 memSize = 6;
inline bool SINGLE_NODE_INFO::has_memsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_memsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SINGLE_NODE_INFO::clear_has_memsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SINGLE_NODE_INFO::clear_memsize() {
  memsize_ = 0u;
  clear_has_memsize();
}
inline ::google::protobuf::uint32 SINGLE_NODE_INFO::memsize() const {
  return memsize_;
}
inline void SINGLE_NODE_INFO::set_memsize(::google::protobuf::uint32 value) {
  set_has_memsize();
  memsize_ = value;
}

// -------------------------------------------------------------------

// COLUMN_INFO

// required string columnName = 1;
inline bool COLUMN_INFO::has_columnname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void COLUMN_INFO::set_has_columnname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void COLUMN_INFO::clear_has_columnname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void COLUMN_INFO::clear_columnname() {
  if (columnname_ != &::google::protobuf::internal::kEmptyString) {
    columnname_->clear();
  }
  clear_has_columnname();
}
inline const ::std::string& COLUMN_INFO::columnname() const {
  return *columnname_;
}
inline void COLUMN_INFO::set_columnname(const ::std::string& value) {
  set_has_columnname();
  if (columnname_ == &::google::protobuf::internal::kEmptyString) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(value);
}
inline void COLUMN_INFO::set_columnname(const char* value) {
  set_has_columnname();
  if (columnname_ == &::google::protobuf::internal::kEmptyString) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(value);
}
inline void COLUMN_INFO::set_columnname(const char* value, size_t size) {
  set_has_columnname();
  if (columnname_ == &::google::protobuf::internal::kEmptyString) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* COLUMN_INFO::mutable_columnname() {
  set_has_columnname();
  if (columnname_ == &::google::protobuf::internal::kEmptyString) {
    columnname_ = new ::std::string;
  }
  return columnname_;
}
inline ::std::string* COLUMN_INFO::release_columnname() {
  clear_has_columnname();
  if (columnname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = columnname_;
    columnname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .COLUMN_INFO.ColumnType columnType = 2;
inline bool COLUMN_INFO::has_columntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void COLUMN_INFO::set_has_columntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void COLUMN_INFO::clear_has_columntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void COLUMN_INFO::clear_columntype() {
  columntype_ = 0;
  clear_has_columntype();
}
inline ::COLUMN_INFO_ColumnType COLUMN_INFO::columntype() const {
  return static_cast< ::COLUMN_INFO_ColumnType >(columntype_);
}
inline void COLUMN_INFO::set_columntype(::COLUMN_INFO_ColumnType value) {
  GOOGLE_DCHECK(::COLUMN_INFO_ColumnType_IsValid(value));
  set_has_columntype();
  columntype_ = value;
}

// -------------------------------------------------------------------

// TB_INFO

// required string tbName = 1;
inline bool TB_INFO::has_tbname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TB_INFO::set_has_tbname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TB_INFO::clear_has_tbname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TB_INFO::clear_tbname() {
  if (tbname_ != &::google::protobuf::internal::kEmptyString) {
    tbname_->clear();
  }
  clear_has_tbname();
}
inline const ::std::string& TB_INFO::tbname() const {
  return *tbname_;
}
inline void TB_INFO::set_tbname(const ::std::string& value) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(value);
}
inline void TB_INFO::set_tbname(const char* value) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(value);
}
inline void TB_INFO::set_tbname(const char* value, size_t size) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TB_INFO::mutable_tbname() {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    tbname_ = new ::std::string;
  }
  return tbname_;
}
inline ::std::string* TB_INFO::release_tbname() {
  clear_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tbname_;
    tbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .COLUMN_INFO columnInfo = 2;
inline int TB_INFO::columninfo_size() const {
  return columninfo_.size();
}
inline void TB_INFO::clear_columninfo() {
  columninfo_.Clear();
}
inline const ::COLUMN_INFO& TB_INFO::columninfo(int index) const {
  return columninfo_.Get(index);
}
inline ::COLUMN_INFO* TB_INFO::mutable_columninfo(int index) {
  return columninfo_.Mutable(index);
}
inline ::COLUMN_INFO* TB_INFO::add_columninfo() {
  return columninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO >&
TB_INFO::columninfo() const {
  return columninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO >*
TB_INFO::mutable_columninfo() {
  return &columninfo_;
}

// required uint32 rowNum = 3;
inline bool TB_INFO::has_rownum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TB_INFO::set_has_rownum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TB_INFO::clear_has_rownum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TB_INFO::clear_rownum() {
  rownum_ = 0u;
  clear_has_rownum();
}
inline ::google::protobuf::uint32 TB_INFO::rownum() const {
  return rownum_;
}
inline void TB_INFO::set_rownum(::google::protobuf::uint32 value) {
  set_has_rownum();
  rownum_ = value;
}

// required uint32 tbSize = 4;
inline bool TB_INFO::has_tbsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TB_INFO::set_has_tbsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TB_INFO::clear_has_tbsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TB_INFO::clear_tbsize() {
  tbsize_ = 0u;
  clear_has_tbsize();
}
inline ::google::protobuf::uint32 TB_INFO::tbsize() const {
  return tbsize_;
}
inline void TB_INFO::set_tbsize(::google::protobuf::uint32 value) {
  set_has_tbsize();
  tbsize_ = value;
}

// -------------------------------------------------------------------

// DATABASE_INFO

// required string dbName = 1;
inline bool DATABASE_INFO::has_dbname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DATABASE_INFO::set_has_dbname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DATABASE_INFO::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DATABASE_INFO::clear_dbname() {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    dbname_->clear();
  }
  clear_has_dbname();
}
inline const ::std::string& DATABASE_INFO::dbname() const {
  return *dbname_;
}
inline void DATABASE_INFO::set_dbname(const ::std::string& value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void DATABASE_INFO::set_dbname(const char* value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void DATABASE_INFO::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DATABASE_INFO::mutable_dbname() {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  return dbname_;
}
inline ::std::string* DATABASE_INFO::release_dbname() {
  clear_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbname_;
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 dbid = 2;
inline bool DATABASE_INFO::has_dbid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DATABASE_INFO::set_has_dbid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DATABASE_INFO::clear_has_dbid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DATABASE_INFO::clear_dbid() {
  dbid_ = 0;
  clear_has_dbid();
}
inline ::google::protobuf::int32 DATABASE_INFO::dbid() const {
  return dbid_;
}
inline void DATABASE_INFO::set_dbid(::google::protobuf::int32 value) {
  set_has_dbid();
  dbid_ = value;
}

// repeated .TB_INFO tbInfo = 3;
inline int DATABASE_INFO::tbinfo_size() const {
  return tbinfo_.size();
}
inline void DATABASE_INFO::clear_tbinfo() {
  tbinfo_.Clear();
}
inline const ::TB_INFO& DATABASE_INFO::tbinfo(int index) const {
  return tbinfo_.Get(index);
}
inline ::TB_INFO* DATABASE_INFO::mutable_tbinfo(int index) {
  return tbinfo_.Mutable(index);
}
inline ::TB_INFO* DATABASE_INFO::add_tbinfo() {
  return tbinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TB_INFO >&
DATABASE_INFO::tbinfo() const {
  return tbinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::TB_INFO >*
DATABASE_INFO::mutable_tbinfo() {
  return &tbinfo_;
}

// -------------------------------------------------------------------

// TASK_INFO

// required uint32 taskType = 1;
inline bool TASK_INFO::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TASK_INFO::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TASK_INFO::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TASK_INFO::clear_tasktype() {
  tasktype_ = 0u;
  clear_has_tasktype();
}
inline ::google::protobuf::uint32 TASK_INFO::tasktype() const {
  return tasktype_;
}
inline void TASK_INFO::set_tasktype(::google::protobuf::uint32 value) {
  set_has_tasktype();
  tasktype_ = value;
}

// required uint32 schedule = 2;
inline bool TASK_INFO::has_schedule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TASK_INFO::set_has_schedule() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TASK_INFO::clear_has_schedule() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TASK_INFO::clear_schedule() {
  schedule_ = 0u;
  clear_has_schedule();
}
inline ::google::protobuf::uint32 TASK_INFO::schedule() const {
  return schedule_;
}
inline void TASK_INFO::set_schedule(::google::protobuf::uint32 value) {
  set_has_schedule();
  schedule_ = value;
}

// -------------------------------------------------------------------

// GROUP_DB_INFO

// required string groupName = 1;
inline bool GROUP_DB_INFO::has_groupname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GROUP_DB_INFO::set_has_groupname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GROUP_DB_INFO::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GROUP_DB_INFO::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& GROUP_DB_INFO::groupname() const {
  return *groupname_;
}
inline void GROUP_DB_INFO::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void GROUP_DB_INFO::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void GROUP_DB_INFO::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GROUP_DB_INFO::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* GROUP_DB_INFO::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated uint32 dbid = 2;
inline int GROUP_DB_INFO::dbid_size() const {
  return dbid_.size();
}
inline void GROUP_DB_INFO::clear_dbid() {
  dbid_.Clear();
}
inline ::google::protobuf::uint32 GROUP_DB_INFO::dbid(int index) const {
  return dbid_.Get(index);
}
inline void GROUP_DB_INFO::set_dbid(int index, ::google::protobuf::uint32 value) {
  dbid_.Set(index, value);
}
inline void GROUP_DB_INFO::add_dbid(::google::protobuf::uint32 value) {
  dbid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GROUP_DB_INFO::dbid() const {
  return dbid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GROUP_DB_INFO::mutable_dbid() {
  return &dbid_;
}

// -------------------------------------------------------------------

// ROWKEY_ENTRY

// optional uint64 rowKey = 1;
inline bool ROWKEY_ENTRY::has_rowkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ROWKEY_ENTRY::set_has_rowkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ROWKEY_ENTRY::clear_has_rowkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ROWKEY_ENTRY::clear_rowkey() {
  rowkey_ = GOOGLE_ULONGLONG(0);
  clear_has_rowkey();
}
inline ::google::protobuf::uint64 ROWKEY_ENTRY::rowkey() const {
  return rowkey_;
}
inline void ROWKEY_ENTRY::set_rowkey(::google::protobuf::uint64 value) {
  set_has_rowkey();
  rowkey_ = value;
}

// required uint64 entry = 2;
inline bool ROWKEY_ENTRY::has_entry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ROWKEY_ENTRY::set_has_entry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ROWKEY_ENTRY::clear_has_entry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ROWKEY_ENTRY::clear_entry() {
  entry_ = GOOGLE_ULONGLONG(0);
  clear_has_entry();
}
inline ::google::protobuf::uint64 ROWKEY_ENTRY::entry() const {
  return entry_;
}
inline void ROWKEY_ENTRY::set_entry(::google::protobuf::uint64 value) {
  set_has_entry();
  entry_ = value;
}

// -------------------------------------------------------------------

// DICT_VALUE

// optional string strValue = 1;
inline bool DICT_VALUE::has_strvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DICT_VALUE::set_has_strvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DICT_VALUE::clear_has_strvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DICT_VALUE::clear_strvalue() {
  if (strvalue_ != &::google::protobuf::internal::kEmptyString) {
    strvalue_->clear();
  }
  clear_has_strvalue();
}
inline const ::std::string& DICT_VALUE::strvalue() const {
  return *strvalue_;
}
inline void DICT_VALUE::set_strvalue(const ::std::string& value) {
  set_has_strvalue();
  if (strvalue_ == &::google::protobuf::internal::kEmptyString) {
    strvalue_ = new ::std::string;
  }
  strvalue_->assign(value);
}
inline void DICT_VALUE::set_strvalue(const char* value) {
  set_has_strvalue();
  if (strvalue_ == &::google::protobuf::internal::kEmptyString) {
    strvalue_ = new ::std::string;
  }
  strvalue_->assign(value);
}
inline void DICT_VALUE::set_strvalue(const char* value, size_t size) {
  set_has_strvalue();
  if (strvalue_ == &::google::protobuf::internal::kEmptyString) {
    strvalue_ = new ::std::string;
  }
  strvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DICT_VALUE::mutable_strvalue() {
  set_has_strvalue();
  if (strvalue_ == &::google::protobuf::internal::kEmptyString) {
    strvalue_ = new ::std::string;
  }
  return strvalue_;
}
inline ::std::string* DICT_VALUE::release_strvalue() {
  clear_has_strvalue();
  if (strvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strvalue_;
    strvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 iValue = 2;
inline bool DICT_VALUE::has_ivalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DICT_VALUE::set_has_ivalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DICT_VALUE::clear_has_ivalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DICT_VALUE::clear_ivalue() {
  ivalue_ = 0;
  clear_has_ivalue();
}
inline ::google::protobuf::int32 DICT_VALUE::ivalue() const {
  return ivalue_;
}
inline void DICT_VALUE::set_ivalue(::google::protobuf::int32 value) {
  set_has_ivalue();
  ivalue_ = value;
}

// optional double dValue = 3;
inline bool DICT_VALUE::has_dvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DICT_VALUE::set_has_dvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DICT_VALUE::clear_has_dvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DICT_VALUE::clear_dvalue() {
  dvalue_ = 0;
  clear_has_dvalue();
}
inline double DICT_VALUE::dvalue() const {
  return dvalue_;
}
inline void DICT_VALUE::set_dvalue(double value) {
  set_has_dvalue();
  dvalue_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COLUMN_INFO_ColumnType>() {
  return ::COLUMN_INFO_ColumnType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
